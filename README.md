# .\JavaScript.js

Last edited time: 9 juin 2024 15:15

# <Sommaire>

- [**Link to an HTML file**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
- [**Output**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
    - [**console.**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
    - [**alert()**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
    - [**prompt()**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
    - [**document.write()**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
    - [**innerHTML**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
- [**Commenté une ligne de command**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
- [Variables](https://www.notion.so/Variables-d203251427134745bf7aad8114cc30d3?pvs=21)
    - [Types de Variables](https://www.notion.so/Types-de-Variables-e05e87aa896f4f1499ae44ba3cfee0c8?pvs=21)
    - [typeof](https://www.notion.so/typeof-4801973e08454affb18173c6e8d7c814?pvs=21)
    - [Operateur](https://www.notion.so/Operateur-63f16f3a226a46e1b66348a930989f86?pvs=21)
    - [**Spread operator**](https://www.notion.so/Spread-operator-cdf6197e3ff740a3bf00adaff20bb644?pvs=21)
    - [Arithmetic operators](https://www.notion.so/Arithmetic-operators-33274c8e2f8c403f837366bca17dbbb7?pvs=21)
    - [Écrivez un code plus court avec des opérateurs simplifiés](https://www.notion.so/crivez-un-code-plus-court-avec-des-op-rateurs-simplifi-s-e5b946d800db423d9ab279ca70210cb8?pvs=21)
    - [Opérateurs logiques](https://www.notion.so/Op-rateurs-logiques-7ab0b1d6fd1948f49037febb2c94f284?pvs=21)
    - [**Opérateurs de comparaison**](https://www.notion.so/Op-rateurs-de-comparaison-af0d8bff59314035ae2e147d8b8d5d64?pvs=21)
    - [**Conversion d’un type vers un autre type**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
- [**Les structures de condition**](https://www.notion.so/Les-structures-de-condition-afe87bd0705043fd929932b9c8ceabcc?pvs=21)
    - [**Truthy and Falsy**](https://www.notion.so/Truthy-and-Falsy-0e10300e226b4a918b92172339ed8cc5?pvs=21)
- [Fonction](https://www.notion.so/Fonction-1526d9956df84c9c90cb9c7cee0ef01f?pvs=21)
    - [**Déclaration de fonction**](https://www.notion.so/D-claration-de-fonction-2091239a0de0418cbecc7ea33fa8f07c?pvs=21)
    - [**Appel de fonction**](https://www.notion.so/Appel-de-fonction-37cba7d5c5434161be46e315b2e60ac1?pvs=21)
    - [**Retour de valeur**](https://www.notion.so/Retour-de-valeur-42f0fa2ed2f34f04b8f94a3e34946048?pvs=21)
    - [**Portée des variables**](https://www.notion.so/Port-e-des-variables-47fbc8b69c304e89aa471d3cb2d8bb13?pvs=21)
    - [**Expression de fonction**](https://www.notion.so/Expression-de-fonction-58f2fd70b248464dab3a4003dcf6fa35?pvs=21)
    - [**Hoisted function**](https://www.notion.so/Hoisted-function-e4ddf2d858854cf28c423b94902c64e0?pvs=21)
    - [**arrow functions**](https://www.notion.so/arrow-functions-3f5c759a802a4fcbafdf2123b12a7cf9?pvs=21)
    - [**higher-order function**](https://www.notion.so/higher-order-function-d56d009876d941a8801ebb00157a8a2f?pvs=21)
    - [**Méthode d'itération**](https://www.notion.so/M-thode-d-it-ration-764e31a08e8e4c888d677f9218609d03?pvs=21)
        - [[**`.forEach()`**](https://www.codecademy.com/resources/docs/javascript/arrays/forEach?page_ref=catalog) ](https://www.notion.so/forEach-cd251f9f7b884430b45b84c6a1454408?pvs=21)
        - [**map()**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
        - [**`findIndex()`**](https://www.notion.so/findIndex-9f06725ea4fb4036842c7b2a22842168?pvs=21)
        - [**reduce()**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
        - [**some()**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
        - [**`filter()`**](https://www.notion.so/filter-9d54211ed3f141ddb28c0544d4078170?pvs=21)
        - [**`find()`** ](https://www.notion.so/find-d29869ab83124e0ea79b2a2c55e5f1c2?pvs=21)
        - [**`sort()`**](https://www.notion.so/sort-070e4f3272d7478496775db5ca23d616?pvs=21)
        - [**every()**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
- [Pratiquer un bon Scoping](https://www.notion.so/Pratiquer-un-bon-Scoping-2675c944b6bd46fd9906c21b52a2f19d?pvs=21)
- [Arrays](https://www.notion.so/Arrays-dce31d1498a7489ba5d13462e4304bf9?pvs=21)
    - [Methodes Built-in pour arrays ](https://www.notion.so/Methodes-Built-in-pour-arrays-d29b1419c1ed493c9e74e88ba6241479?pvs=21)
- [String](https://www.notion.so/String-062a1b15294c45259d36ec71e9fb0fa5?pvs=21)
    - [**String Concatenation**](https://www.notion.so/String-Concatenation-3ac3e2fe402e4a8da497f700f3171b2d?pvs=21)
- [**RegExp**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
- [**ASCII**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
- [Boucle](https://www.notion.so/Boucle-d924352b8d42480da6a74d0ad5052b3d?pvs=21)
    - [for](https://www.notion.so/for-a41d1708a8934c179be3c12ed6e87c62?pvs=21)
    - [**while**](https://www.notion.so/while-b0eca8fef298426d8908949b172c68ec?pvs=21)
    - [**do...while**](https://www.notion.so/do-while-3bdfc60889694892b49c7cc0cca760b0?pvs=21)
    - [**Utilisation de `Break`**](https://www.notion.so/Utilisation-de-Break-f63e2e34de19439c8811f553370c6f71?pvs=21)
    - [**Utilisation de `continue`**](https://www.notion.so/Utilisation-de-continue-e6f6a35353f74cbb989bfbb9eb6105a1?pvs=21)
- [Built-In Fonction](https://www.notion.so/Built-In-Fonction-a3c4a5ca0fae4d609b4388409a756a57?pvs=21)
    - [**Méthode** :](https://www.notion.so/M-thode-0bd1463c8ab14999b178ec803cea276b?pvs=21)
    - [Math Object](https://www.notion.so/Math-Object-2c320cd2e3914e7890d76d2748332b04?pvs=21)
    - [Number Object](https://www.notion.so/Number-Object-cee1f570279c48339fd53d72fe9a6ce5?pvs=21)
- [Object](https://www.notion.so/Object-e1d68c5019a74f11bd7b0b448d279d78?pvs=21)
    - [this](https://www.notion.so/this-2359fcf2f25843baaf1a1ce9626bbc82?pvs=21)
    - [**Set()**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
    - [**Built-in Object Methods**](https://www.notion.so/Built-in-Object-Methods-f39325244d4948fa92c7085b3f7aa74a?pvs=21)
    - [**Privacy**](https://www.notion.so/Privacy-15434c3cc6114752957d680d965e5df9?pvs=21)
    - [**Getters**](https://www.notion.so/Getters-f3517a8f9bf2417ea34a8746d95cefc6?pvs=21)
    - [**Setters** :](https://www.notion.so/Setters-be3e56c556044a20b9cf9e9d54265641?pvs=21)
    - [Factory Functions](https://www.notion.so/Factory-Functions-6d2d4bd9150c458398d3504c8b86264c?pvs=21)
- [**Try/Catch**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
- [Built-In Fonction](https://www.notion.so/Built-In-Fonction-a3c4a5ca0fae4d609b4388409a756a57?pvs=21)
    - [**Methodes Built-in pour string**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
    - [**Méthodes pour arrays**](https://www.notion.so/JavaScript-js-1ab66c37a9e74d499f189c8e82ba4e86?pvs=21)
    - [**Méthode** :](https://www.notion.so/M-thode-0bd1463c8ab14999b178ec803cea276b?pvs=21)
    - [Math Object](https://www.notion.so/Math-Object-2c320cd2e3914e7890d76d2748332b04?pvs=21)
    - [Number Object](https://www.notion.so/Number-Object-cee1f570279c48339fd53d72fe9a6ce5?pvs=21)

# Link to an HTML file

```jsx
<script src="myJsFile.js"></script>
```

Vous pouvez vraiment le placer n'importe où. Elle fonctionnera. Mais la **meilleure** pratique consiste à la placer à la toute **fin** de votre **document**, juste **avant** **</body>**

# **Commenté une ligne de command**

- **`//`** commente une seul ligne.
- `/* */` commente plusieurs ligne

# Output

- **console.**
    1. **Affichage de messages** : La méthode principale est **`console.log()`**, qui affiche des messages dans la console (comme le **`print()`** de python). Vous pouvez passer plusieurs arguments à **`console.log()`** et ils seront affichés séparément dans la console.
    2. **Autres méthodes** : En plus de **`log()`**, la commande **`console`** offre d'autres méthodes utiles telles que **`error()`**, **`warn()`**, **`info()`**, **`debug()`**, et **`assert()`**. Chacune de ces méthodes est utilisée pour afficher différents types de messages ou pour signaler des erreurs.
    3. **Interpolation de chaînes** : Vous pouvez utiliser l'interpolation de chaînes avec **`console.log()`** en utilisant des backticks (`) et en incorporant des variables JavaScript directement dans la chaîne.
    4. **Tableaux et objets** : Lorsque vous passez un tableau ou un objet à **`console.log()`**, il est généralement affiché de manière structurée dans la console, facilitant ainsi le débogage des données complexes.
    5. **Groupement de messages** : Vous pouvez regrouper des messages dans la console en utilisant **`console.group()`** et **`console.groupEnd()`**. Cela est utile pour organiser les messages dans la console lors du débogage de sections spécifiques de votre code.
    6. **Chronométrage** : **`console.time()`** et **`console.timeEnd()`** peuvent être utilisés pour mesurer le temps d'exécution de portions de code. Vous démarrez le chronomètre avec **`console.time()`** et l'arrêtez avec **`console.timeEnd()`**.
    7. **Nettoyage de la console** : Vous pouvez effacer la console avec **`console.clear()`**. Cela peut être utile lorsque vous voulez un environnement de console propre pour afficher de nouveaux messages.
    8. **Niveaux de journalisation** : La plupart des méthodes de la commande **`console`** ont des niveaux de gravité associés, comme "log", "warn", "error", etc. Cela peut être utile pour filtrer les messages dans la console en fonction de leur importance.
    9. **Compatibilité** : navigateurs modernes et Node.js

## **alert()**

**`alert()`** : C'est une méthode spécifique au navigateur qui affiche une boîte de dialogue modale avec le message spécifié. Elle est souvent utilisée pour afficher des informations importantes à l'utilisateur.

```jsx
alert("This is an alert message!");
```

## **Prompt()**

**`Prompt()`** : Cette méthode spécifique au navigateur affiche une boîte de dialogue **permettant à l'utilisateur de saisir une valeur**. Elle est souvent utilisée pour demander des informations à l'utilisateur.

```jsx
prompt("Enter your name:");
```

## **document.write()**

**`document.write()`** : Cette méthode **écrit directement dans le document HTML**. Cependant, elle est **moins couramment utilisée** car elle remplace le contenu de la page HTML existante si elle est appelée après que le document ait été entièrement chargé.

```jsx
document.write("This will be written in the document.");
```

## **innerHTML**

**`innerHTML`** : Cette propriété permet de modifier le contenu HTML d'un élément spécifique de la page. Elle est souvent utilisée pour mettre à jour dynamiquement le contenu d'une page Web.

```jsx
document.getElementById("myElement").innerHTML = "New content";
```

# Variables

Pour déclarer une variable en JavaScript, l'un de ces trois mots-clés peut être utilisé avec un nom de variable (Avant la version ES6, utiliser le mot-clé var pour déclarer des variables.) :

## **var**

abréviation de variable, est un mot-clé JavaScript qui permet de créer, ou de déclarer, une nouvelle variable. **`var`** sont **soumises à l'hoisting,** ce qui signifie qu'elles sont déplacées au début de leur portée. Cela signifie que vous pouvez utiliser une variable **`var`** avant sa déclaration effective dans le code. 

```jsx
x = 7;
console.log(x); //Output >>> 7
var x;
```

## **let**

signale que la variable peut se voir re-attribuer une valeur différente. Il s'agit d'une variable de bloc.

## **const**

est la manière préférée de déclarer une variable avec une valeur constante. Il s'agit également d'un bloc. 

- **Ne peut pas être réaffectée** = **`TypeError`**
- **Pas de valeur** = **`SyntaxError`**

**Sans attribuer de valeur variable var= initialisé avec une valeur** **`undefined`(on appel cela hoisting) alors que let et const donne une ERROR** :

![Untitled](JavaScript%20js%201ab66c37a9e74d499f189c8e82ba4e86/Untitled.png)

## Types de Variables

 **`let`** est utilisé pour **déclarer une variable**

1. **Nombre (Number)** : Les nombres représentent des valeurs numériques, qu'elles soient entières ou décimales. Par exemple : **`let x = 10;`** ou **`let y = 3.14;`**
2. **Chaîne de caractères (String)** : Les chaînes de caractères représentent des séquences de caractères, délimitées par des guillemets simples ('') ou doubles (""). Par exemple : **`let nom = 'Jean';`**
3. **Booléen (Boolean)** : Les booléens représentent des valeurs de vérité, soit **`true`** (vrai) ou **`false`** (faux). Par exemple : **`let estVrai = true;`**
4. **Null** : Null représente l'absence intentionnelle de toute valeur ou objet. Par exemple : **`let valeur = null;`**
5. **Indéfini (Undefined)** : Undefined représente une variable qui a été déclarée mais pas initialisée, ou une propriété qui n'existe pas dans un objet. Par exemple : **`let x;`** ou **`let objet = {}; console.log(objet.nonExistant);`**
6. **Objet (Object)** : Les objets sont des collections de paires clé-valeur, où chaque valeur est accessible par une clé. Par exemple :
    
    ```jsx
    let personne = {
        nom: 'Jean',
        age: 30
    };
    ```
    
7. **Symbole (Symbol)** : Les symboles sont des valeurs uniques qui peuvent être utilisées comme identifiants pour les propriétés des objets. Ils sont créés à l'aide de la fonction **`Symbol()`**. Par exemple :
    
    ```jsx
    const cle = Symbol('cle_unique');
    ```
    
8. **Tableau (Array)** : Les tableaux sont des listes ordonnées d'éléments. Les éléments d'un tableau peuvent être de n'importe quel type de données. Par exemple :
    
    ```jsx
    let nombres = [1, 2, 3, 4, 5];
    ```
    
9. **Fonction (Function)** : Les fonctions sont des objets qui peuvent être appelés pour effectuer une tâche spécifique. Elles peuvent être stockées dans des variables et passées en tant qu'arguments à d'autres fonctions. Par exemple :
    
    ```jsx
    function additionner(a, b) {
        return a + b;
    }
    ```
    

Ces différents types de variables permettent à JavaScript d'être un langage de programmation flexible et puissant, capable de manipuler divers types de données de manière efficace.

### typeof

**`typeof`** : utilisé pour **déterminer le type de données d'une variable** ou d'une expression. Il renvoie une chaîne de caractères représentant le type de données de l'opérande. 

- syntax : **`typeof variable`**

# Operateur

- `+` : addition
- `-` : subtraction
- `*` : multiplication
- `/` : division

## **Spread operator**

Permet de décomposer un objet itérable (comme un tableau ou une chaîne de caractères) en éléments individuels. Il peut être utilisé dans plusieurs contextes en JavaScript, notamment lors de la création de tableaux, d'arguments de fonction, de copie d'objets, etc.

1. **Décomposition de tableaux** : Vous pouvez utiliser le spread operator pour décomposer un tableau en éléments individuels. Cela peut être utile lors de la création de nouveaux tableaux en combinant plusieurs tableaux ou en ajoutant de nouveaux éléments.
    
    ```jsx
    const array1 = [1, 2, 3];
    const array2 = [4, 5, 6];
    const combinedArray = [...array1, ...array2];
    console.log(combinedArray); // Output: [1, 2, 3, 4, 5, 6]
    ```
    
2. **Passage d'arguments de fonction** : Le spread operator peut être utilisé pour passer un nombre variable d'arguments à une fonction.
    
    ```jsx
    function sum(a, b, c) {
      return a + b + c;
    }
    const numbers = [1, 2, 3];
    console.log(sum(...numbers)); // Output: 6
    ```
    
3. **Copie d'objets** : Vous pouvez utiliser le spread operator pour créer une copie superficielle (shallow copy) d'un objet.
    
    ```jsx
    const originalObject = { a: 1, b: 2 };
    const copiedObject = { ...originalObject };
    console.log(copiedObject); // Output: { a: 1, b: 2 }
    ```
    
    Il est important de noter que le spread operator effectue une copie superficielle lorsqu'il est utilisé sur des objets, ce qui **signifie que les objets imbriqués ne sont pas clonés en profondeur**. Si les objets contiennent des objets imbriqués ou des références à d'autres objets, ces références seront partagées entre l'objet original et la copie.
    

## Arithmetic operators

- `%` modulo : **retourne le reste** de la division euclidienne
- **`**`** puissance : élève un nombre à une certaine puissance
- `//` division entière : calcule la division entière (arrondie vers le bas)

### Écrivez un code plus court avec des opérateurs simplifiés

Lorsque vous souhaitez **modifier** une **variable** **en modifiant la valeur initiale via un opérateur** de base, vous pouvez utiliser une version raccourcie. En d'autres termes, vous pouvez utiliser des opérateurs simplifiés ! **Par exemple**, au lieu d'utiliser l'expression **`savingsAccount = savingsAccount + 100`** pour ajouter 100 $ à votre variable, vous pouvez utiliser une sorte d'opérateur combiné arithmétique/assignation += :

- **`-=`** pour une soustraction
- **`+=`** pour une addition
- **`*=`** pour une multiplication
- **`/=`** pour division
- **`%=`** pour le reste de la division entière

**Increment and Decrement Operator**

- **`i++` = `i = i + 1`**
- **`i--` = `i = i - 1`**

## Opérateurs logiques

Ces opérateurs vous permettent de combiner plusieurs valeurs booléennes : des valeurs booléennes spécifiques ou des résultats d'expressions. Il y en a trois :

### **`&&`** : l'opérateur **ET**

Le résultat final est vrai seulement lorsque toutes les expressions/valeurs sont vraies. Par exemple : le résultat de **`expression1 && expression2`** sera vrai seulement si **`expression1`** est vrai ET **`expression2`** est également vrai.

### **`||`** : l'opérateur **OU**.

Le résultat final est vrai lorsque au moins l'une des expressions/valeurs est vraie. Par exemple : le résultat de **`expression1 || expression2`** sera vrai si **`expression1`** est vrai OU **`expression2`** est vrai.

### **`!`** : l'opérateur **NON**.

Cela inverse simplement le résultat de l'expression donnée. Par exemple, le résultat de               **`!(expression)`** est vrai lorsque **`expression`** est faux.

```jsx
let excited = true;
console.log(!excited); // Prints false

let sleepy = false;
console.log(!sleepy); // Prints true
```

## **Opérateurs de comparaison**

Les opérateurs de comparaison sont utilisés pour comparer des valeurs et renvoyer un résultat booléen (vrai ou faux) selon la comparaison.

- **`==`** : **égal non-stricte >** après avoir **effectué une conversion de type si nécessaire**.
- **`===`** : **égal stricte > sans effectuer de conversion de type** (considérée comme plus sûre et prévisible).
- **`!=`** : **différent non-strict > après avoir effectué une conversion de type si nécessaire.**
- **`!==` : différent strict > sans effectuer de conversion de type.**
- **`<`** : **inférieur à**
- **`>`** : **supérieur à**
- **`<=`** : **inférieur ou égal à**
- **`>=`** : **supérieur ou égal à**

## **Conversion d’un type vers un autre type**

- **`String()`** : **Convertit la valeur** passée en argument en une **chaîne de caractères(=Fonction).**
- **`toString()` :** est une **méthode** intégrée qui est utilisée pour **convertir un objet** en une **représentation de chaîne de caractères**.
- **`Boolean()`**: **Convertit la valeur** passée en argument en un **booléen (`true` ou `false`).**
- **`Number()` :** Convertit la valeur passée en argument en un nombre (=Fonction).
- **`Array()` : Convertit la valeur** passée en argument en un **tableau**.
    
    ```jsx
    let ls = "123"
    let new_array = Array(ls);
    console.log(new_array)
    ```
    
    - **Convertir un Integer en un Tableau** :
        
        ```jsx
        let tableauChiffres = Array.from(String(nombre), Number);
        // ou
        let tableauChiffres = String(nombre).split("").map(Number);
        console.log(tableauChiffres); // Output: [1, 2, 3, 4, 5]
        ```
        
    - **Creation de tableau vide** :
        
        ```jsx
        let tableauVide = new Array();
        ```
        
    - **Création d'un tableau avec des éléments initiaux :**
        
        ```jsx
        let tableau = new Array(1, 2, 3);
        // Équivalent à let tableau = [1, 2, 3];
        ```
        
    - **Création d'un tableau avec une taille spécifiée**
        
        ```jsx
        let tableauVideLongueur = new Array(5);
        // Crée un tableau vide avec une longueur de 5
        ```
        
- **`.split()` :** Méthode qui divise la **chaîne de caractères** en un **tableau de sous-chaînes**, en utilisant un séparateur spécifié.
    
    ```jsx
    const str = "apple,banana,orange";
    console.log(str.split(",")); // Output: ["apple", "banana", "orange"]
    ```
    
- **`parseInt()`** : Cette fonction **analyse** un **string** et **renvoie** un **Integer** (=Fonction).
    
    ```jsx
    const str = "42";
    const integer = parseInt(str);
    console.log(integer); // Output: 42
    
    ```
    
    **`parseInt()`** peut également **prendre un deuxième argument**, la **base** dans laquelle le nombre doit être interprété.
    
    ```jsx
    const str = "1010";
    const integer = parseInt(str, 2); // Interprétation en base 2 (binaire)
    console.log(integer); // Output: 10
    
    ```
    
- **`parseFloat()` : est une fonction intégrée qui est utilisée pour analyser une chaîne de caractères et renvoyer un nombre à virgule float.** Elle analyse la chaîne de caractères jusqu'à ce qu'elle **atteigne un caractère qui ne correspond pas** à un chiffre valide ou à un point décimal, puis elle retourne le nombre qu'elle a pu analyser jusqu'à ce point.
    
    ```jsx
    const str = "3.14 meters";
    const num = parseFloat(str);
    console.log(num); // Output: 3.14
    ```
    

# **Les structures de condition**

En JavaScript, les structures de condition sont des éléments clés pour contrôler le flux d'exécution du code en fonction de certaines conditions. Les structures de condition les plus couramment utilisées sont les suivantes :

1. **if...else** : Cette structure permet d'exécuter un bloc de code si une **condition est** **`True`** et un **else** si la condition est `False`.
    
    ```jsx
    if (condition) {
        // Bloc de code à exécuter si la condition est vraie
    } else {
        // Bloc de code à exécuter si la condition est fausse
    }
    ```
    
2. **if...else if...else** : Cette structure permet de **tester plusieurs conditions** les unes après les autres.
    
    ```jsx
    if (condition1) {
        // Bloc de code à exécuter si condition1 est vraie
    } else if (condition2) {
        // Bloc de code à exécuter si condition1 est fausse et condition2 est vraie
    } else {
        // Bloc de code à exécuter si toutes les conditions sont fausses
    }
    ```
    
3. **switch...case** : Cette structure permet de tester une seule variable contre une liste de valeurs possibles.
    
    ```jsx
    switch (variable) {
        case valeur1:
            // Bloc de code à exécuter si variable est égale à valeur1
            break;
        case valeur2:
            // Bloc de code à exécuter si variable est égale à valeur2
            break;
        default:
            // Bloc de code à exécuter si variable n'est égale à aucune des valeurs précédentes
    }
    ```
    
    - Le mot-clé **`switch`** lance l'instruction et est suivi de ( ... ), qui contient la valeur que chaque **`case`** comparera. Dans l'exemple, la valeur ou l'expression de l'instruction **`switch`** est **`variable`**
    - À l'intérieur du bloc, **`{ ... }`**, il y a plusieurs **`case`**s. Le mot-clé **`case`** vérifie si l'expression correspond à la valeur spécifiée qui vient après. La valeur suivant le premier **`case`** est **`'valeur1'`**. Si la valeur de **`variable`** était égale à **`'valeur1'`**, le **`console.log()`** de ce **`case`** serait exécuté.
    - Le mot-clé **`break`** indique à l'ordinateur de quitter le bloc et de ne plus exécuter de code ni de vérifier d'autres cas à l'intérieur du bloc de code. Remarque : sans mot-clé **`break`**, le premier cas correspondant sera exécuté, mais aussi tous les cas suivants, qu'ils correspondent ou non, y compris le cas par défaut. Ce comportement est différent de celui des instructions conditionnelles **`if`**/**`else`** qui n'exécutent qu'un seul bloc de code.
4. **Ternaire (opérateur ternaire)** : C'est une expression conditionnelle concise utilisée comme raccourci pour la structure if...else.
    
    ```jsx
    (condition) ? valeurSiVraie : valeurSiFausse;
    
    ```
    
    - **`?` :** Il sépare la condition de ses résultats possibles.
    - si la condition est vraie, la valeur "valeurSiVraie" est retournée ; sinon, la valeur "valeurSiFausse" est retournée.
    - **condition évalue** : séparées par deux points **`:`**.
    
    Voici un exemple d'utilisation de la structure if...else en JavaScript :
    
    ```jsx
    let age = 18;
    
    if (age >= 18) {
        console.log("Vous êtes majeur.");
    } else {
        console.log("Vous êtes mineur.");
    }
    
    ```
    
    Dans cet exemple, si la variable `age` est supérieure ou égale à 18, le message "Vous êtes majeur." est affiché. Sinon, le message "Vous êtes mineur." est affiché.
    
    ## **Truthy and Falsy**
    
    ```jsx
    let myVariable = 'I Exist!';
    if (myVariable) {
       console.log(myVariable)
    } else {
       console.log('The variable does not exist.')
    }
    ```
    
    Tous le valeur retourneront **Truthy** sauf la liste des valeurs erronées comprend ces principales valeurs **`falsy` =**
    
    - **`0`**
    - Les chaînes vides comme `""` ou `''`.
    - **`null`** qui représente l'absence totale de valeur
    - **`undefined`** qui représente le fait qu'une variable déclarée n'a pas de valeur
    - **`NaN` (**Not a Number)
    
    [Exemple Situation Utile](https://www.notion.so/Exemple-Situation-Utile-9caa406471de4b369d4ae10c58d4a777?pvs=21)
    

# Fonction

Les fonctions sont des **blocs de code réutilisables** qui effectuent une tâche spécifique. Voici ce qu'il faut savoir sur les fonctions en JavaScript :

1. **Déclaration de fonction**
    - Vous pouvez déclarer une fonction en utilisant le mot-clé **`function`**.
    - Une fonction peut avoir un nom et prendre des paramètres, ou elle peut être anonyme et ne pas avoir de nom.
    
    Exemples :
    
    ```jsx
    // Fonction nommée
    function maFonction(parametre1, parametre2) {
        // Bloc de code
    }
    
    // Fonction anonyme
    let maFonctionAnonyme = function(parametre1, parametre2) {
        // Bloc de code
    };
    ```
    
2. **Appel de fonction**
    - Pour exécuter le code à l'intérieur d'une fonction, vous devez l'appeler en utilisant son nom suivi de parenthèses.
    - Si la fonction prend des paramètres, vous devez fournir des valeurs pour ces paramètres lors de l'appel de la fonction.
    
    Exemple :
    
    ```jsx
    maFonction(valeur1, valeur2); // Appel de la fonction maFonction avec des paramètres
    
    ```
    
3. **Retour de valeur**
    - Une fonction peut retourner une valeur à l'endroit où elle est appelée à l'aide du mot-clé `return`.
    - Si aucune instruction `return` n'est spécifiée, la fonction retourne `undefined` par défaut.
    
    Exemple :
    
    ```jsx
    function addition(a, b) {
        return a + b;
    }
    
    let resultat = addition(3, 5); // resultat vaut 8
    ```
    
4. **Portée des variables**
    - Les variables déclarées à l'intérieur d'une fonction sont locales à cette fonction et ne sont pas accessibles en dehors de celle-ci (à moins qu'elles ne soient déclarées dans une portée plus large).
    - Les variables déclarées à l'extérieur des fonctions sont globales et peuvent être accessibles depuis n'importe où dans le script.
5. **Expression de fonction**
    - Outre la déclaration de fonction standard, vous pouvez **également créer des fonctions en tant qu'expressions de fonction.**
    - Les expressions de fonction peuvent être **nommées ou anonymes** et peuvent être **assignées à des variables.**
    
    Ex:
    
    ```jsx
    let maFonction = function(parametre) {
        // Bloc de code
    };
    ```
    
6. **Hoisted function**
    
    Cela signifie que la déclaration de la fonction est déplacée au début de son contexte d'exécution lors de la compilation, même si la déclaration apparaît plus tard dans le code source.
    
    Par exemple, considérez ce code :
    
    ```jsx
    sayHello();
    function sayHello() {
      console.log("Hello!");
    }
    ```
    
    Il est important de noter que seule la déclaration de la fonction est soumise au hoisting, pas l'initialisation. Par exemple :
    
    ```jsx
    sayHello(); // Error: sayHello is not a function
    var sayHello = function() {
      console.log("Hello!");
    };
    ```
    
    Même si **`sayHello()`** est appelé avant sa déclaration, le code fonctionnera correctement. Cela est dû au hoisting : la déclaration de la fonction **`sayHello()`** est déplacée au début de son contexte d'exécution lors de la compilation, de sorte qu'elle est disponible pour être appelée à tout moment dans ce contexte.
    
7. **arrow functions**
    
    Les fonctions fléchées (**`arrow functions`**) sont une **syntaxe plus concise** par rapport aux fonctions traditionnelles, ce qui les rend très populaires et largement utilisées. Voici comment elles fonctionnent :
    
    ### Syntaxe des fonctions fléchées :
    
    1. **Sans** **paramètre sur une seule ligne:**
        
        ```jsx
        const maFonction = () => expression;
        // const direBonjour = () => console.log('Bonjour!');
        
        ```
        
    2. **Avec un seul paramètre** **sur une seule ligne**:
        
        ```jsx
        const maFonction = param => expression;
        // ex : const carre = x => x * x;
        
        ```
        
    3. **Avec plusieurs paramètres** **sur une seule ligne**:
        
        ```jsx
        const maFonction = (param1, param2) => expression;
        // ex : const addition = (a, b) => a + b;
        ```
        
    4. **Avec un corps de fonction sur plusieurs lignes (block body)** :
        
        ```jsx
        const maFonction = (a,b) => {
            // Bloc de code
            return expression;
        }
        /* ex: const calculerSomme = (a, b) => {
            let somme = a + b;
            return somme;
        } */ 
        ```
        
        - Besoin de **curly bracket `{}`**
        - Besoin du **return (contrairement au one line)**
    
    ### Avantages des fonctions fléchées :
    
    - **Syntaxe concise** : Les fonctions fléchées permettent de définir des fonctions de manière plus concise, ce qui rend le code plus lisible et compact.
    - **`this` lié lexicalement** : En utilisant des fonctions fléchées, la valeur de `this` est déterminée par le contexte lexical de la fonction plutôt que par la manière dont elle est appelée. Cela évite les erreurs courantes liées à la portée de `this` dans les fonctions traditionnelles.
8. **higher-order function**
    
    C’est une fonction qui **prend une ou plusieurs fonctions** en tant qu'**arguments** et/ou qui **retourne une fonction en tant que résultat**. En d'autres termes, une fonction de premier ordre traite d'autres fonctions comme des valeurs.
    
    ```jsx
    // Fonction prenant une fonction en tant qu'argument
    function appliquerOperation(operation, a, b) {
        return operation(a, b);
    }
    // Définition de fonctions qui peuvent être passées en tant qu'argument
    function additionner(x, y) {
        return x + y;
    }
    function soustraire(x, y) {
        return x - y;
    }
    // Appels de fonction en passant les fonctions en tant qu'argument
    console.log(appliquerOperation(additionner, 5, 3)); // Affiche 8
    console.log(appliquerOperation(soustraire, 10, 4)); // Affiche 6
    ```
    
9. **Méthode d'itération**
    - [**`.forEach()`**](https://www.codecademy.com/resources/docs/javascript/arrays/forEach?page_ref=catalog)
        
        Exécutera le même code pour chaque élément d'un tableau.
        
    
    ![https://content.codecademy.com/courses/learn-javascript-iterators/iterator anatomy.svg](https://content.codecademy.com/courses/learn-javascript-iterators/iterator anatomy.svg)
    
    Le code ci-dessus affichera une liste joliment formatée des courses dans la console. Explorons la **syntaxe** d'invocation de **`.forEach()`**.
    
    - `groceries.forEach()` appelle la méthode `forEach` sur le tableau `groceries`.
    - `.forEach()` prend un argument de fonction de rappel. N'oubliez pas, une fonction de rappel est une fonction passée en argument dans une autre fonction.
    - `.forEach()` parcourt le tableau et exécute la fonction de rappel pour chaque élément. Lors de chaque exécution, l'élément courant est passé en argument à la fonction de rappel.
    - La valeur de retour pour `.forEach()` sera toujours `undefined`.
    
    ```jsx
    const array1 = ['a', 'b', 'c'];
    array1.forEach((element) => console.log(element));
    // Expected output: "a"
    // Expected output: "b"
    // Expected output: "c"
    ```
    
    - **`map()`** :
        - La méthode **`map()`** **crée un nouveau tableau contenant les résultats de l'application d'une fonction de transformation à chaque élément du tableau d'origine.**
        - Elle renvoie un nouveau tableau résultant de l'application de la fonction de transformation à chaque élément.
        - Elle ne modifie pas le tableau d'origine.
            
            ```jsx
            const numbers = [1, 2, 3, 4, 5];
            const squareNumbers = numbers.map(num => num * num);
            // squareNumbers contiendra [1, 4, 9, 16, 25], car chaque élément est élevécost
            ```
            
    - **`findIndex()`**
        - La méthode **`findIndex()`**est utilisée pour **trouver l'index du premier élément** dans un tableau qui **satisfait une condition spécifique.**
        - Elle prend en argument une callback function qui définit la condition de recherche.
        - **Renvoie l'index de l'élément trouvé**, ou **-1** si aucun élément ne satisfait la condition.
    
    ```jsx
    const numbers = [10, 20, 30, 40, 50];
    const index = numbers.findIndex(number => number > 25);
    console.log(index); // Affiche 2, car 30 est le premier nombre supérieur à 25
    ```
    
    - **`reduce()`** :
        - La méthode **`reduce()` est utilisée pour réduire les éléments d'un tableau à une seule valeur.**
        - Elle prend en argument une fonction de rappel et une valeur initiale optionnelle.
        - La fonction de rappel prend deux arguments (l'accumulateur et l'élément actuel) et retourne la valeur résultante de l'opération.
        - Elle itère sur chaque élément du tableau et utilise la valeur retournée par la fonction de rappel comme nouvel accumulateur pour l'itération suivante.
        
        ```jsx
        const numbers = [1, 2, 3, 4, 5];
        const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
        console.log(sum); // Affiche 15, car c'est la somme de tous les éléments du tableau
        ```
        
    - **`filter()`**
        
        Cette méthode est utilisée pour **filtrer les éléments d'un tableau** en fonction d'un **critère donné** et **renvoyer un nouveau tableau** contenant les éléments qui satisfont ce critère.
        
        ```jsx
        const numbers = [1, 2, 3, 4, 5, 6];
        const evenNumbers = numbers.filter(num => num % 2 === 0);
        console.log(evenNumbers); // Output: [2, 4, 6]
        ```
        
    - **`sort()`**
        
        Cette méthode est utilisée pour **trier les éléments d'un tableau** selon un **ordre spécifié**. 
        
        - **Par défaut**, elle **trie** les éléments **comme des string** et les trie en **ordre lexicographique.**
        
        ```jsx
        const fruits = ["banana", "apple", "orange", "kiwi"];
        fruits.sort();
        console.log(fruits); // Output: ["apple", "banana", "kiwi", "orange"]
        ```
        
        Cependant, pour **trier les nombres**, vous devez **fournir une fonction de comparaison**.
        
        Exemple de tri numérique :
        
        ```jsx
        const numbers = [3, 1, 5, 2, 4];
        numbers.sort((a, b) => a - b);
        console.log(numbers); // Output: [1, 2, 3, 4, 5]
        ```
        
    - **`find()`**
        
        Cette méthode **renvoie la première valeur d'un tableau** qui **satisfait une condition donnée**. Si **aucune valeur** ne satisfait la condition, elle **renvoie** **`undefined`**.
        
        ```jsx
        const fruits = ["apple", "banana", "orange", "kiwi"];
        const fruit = fruits.find(fruit => fruit === "orange");
        console.log(fruit); // Output: "orange"
        ```
        
    - **`some()`** :
        - La méthode **`some()`** est utilisée pour **vérifier si au moins un élément** d'un tableau **satisfait** une **condition spécifique**.
        - Elle **prend en argument** une fonction de rappel qui définit la condition de vérification.
        - Elle renvoie **`true`** si au moins un élément du tableau satisfait la condition, sinon elle renvoie **`false`**.
        
        ```jsx
        const numbers = [10, 20, 30, 40, 50];
        const hasEvenNumber = numbers.some(number => number % 2 === 0);
        console.log(hasEvenNumber); // Affiche true, car il y a au moins un nombre pair dans le tableau
        ```
        
    - **`every()`**
        - La méthode **`every()`** est utilisée pour **vérifier si tous les éléments d'un tableau satisfont une condition spécifique**.
        - Elle prend en argument une fonction de rappel qui définit la condition de vérification.
        - Elle renvoie **`true`** si tous les éléments du tableau satisfont la condition, sinon elle renvoie **`false`**
        
        ```jsx
        const numbers = [10, 20, 30, 40, 50];
        const allNumbersGreaterThanZero = numbers.every(number => number > 0);
        console.log(allNumbersGreaterThanZero); // Affiche true, car tous les nombres sont supérieurs à zéro
        ```
        
10. **Méthodes de fonctions prédéfinies** :
    - JavaScript fournit un certain nombre de méthodes prédéfinies pour les fonctions, telles que `call()`, `apply()`, et `bind()`, qui permettent de contrôler la valeur de `this` lors de l'exécution d'une fonction.

# Pratiquer un bon Scoping

Compte tenu des défis posés par les variables globales et la pollution du scop, nous devrions suivre les meilleures pratiques pour délimiter le scop de nos variables aussi étroitement que possible en utilisant le champ d'application du bloc.

Un **cadrage serré** de vos **variables améliorera** grandement votre code de plusieurs façons :

- Il rendra votre **code plus lisible** puisque les **blocs organiseront** votre code en **sections** distinctes.
- Il rend votre code plus compréhensible car il **clarifie quelles variables sont associées aux différentes parties** du programme plutôt que d'avoir à les suivre ligne après ligne !
- Il est plus **facile de maintenir votre code**, puisqu'il est modulaire.
- Il permet d'**économiser de la mémoire** dans votre code c**ar il cessera d'exister une fois que le bloc aura fini de s'exécuter.**

# Arrays

Les tableaux sont la façon dont JavaScript crée des **listes**. Les tableaux peuvent stocker n'importe quel type de données (y compris des chaînes de caractères, des nombres et des booléens). Comme les listes, les tableaux sont ordonnés, c'est-à-dire que chaque élément a une position numérotée.

- **Syntax** :
    
    ```jsx
    let tableauVide = []; // Déclaration d'un tableau vide
    let tableauNb = [1, 2, 3, 4, 5]; // Déclaration d'un tableau de nombres
    tableauNb = []; //Vide le tableau
    tableauNb.splice(0, tableauNb.length); // Supprime tous les éléments du tableau
    let tableauMixte = [1, 'hello', true]; // Déclaration d'un tableau de types de données mixtes
    ```
    
- **Accès élements d’un tableau :**
    
    Chaque élément **possédent** sont propre **index** à partir de **0**
    
    ```jsx
    let tableau = ['a', 'b', 'c'];
    console.log(tableau[0]); // Affiche 'a'
    ```
    
- **Longueur d'un tableau** :
    
    Vous pouvez obtenir la longueur d'un tableau en utilisant la propriété `length`.
    
    ```jsx
    let tableau = [1, 2, 3, 4, 5];
    console.log(tableau.length); // Affiche 5
    ```
    
- **Modification d'un tableau** :
    
    Vous pouvez modifier un élément spécifique d'un tableau en accédant à son index et en lui assignant une nouvelle valeur.
    
    ```jsx
    let tableau = [1, 2, 3];
    tableau[1] = 'a'; // Modification de la valeur à l'index 1
    tableau.push(4); // Ajout de 4 à la fin du tableau
    tableau.pop(); // Suppression du dernier élément (4)
    ```
    
- **Créés à l'aide de la classe Array en utilisant le mot-clé new**
    
    et en transmettant les éléments sous forme d'arguments séparés par des virgules 
    
    ```jsx
    const musicGenres = new Array('Rock', 'Pop', 'Country');
    ```
    

# Methodes Built-in pour arrays

- **`.at()`**
    
    prend un **entier en argument** et **renvoie l'élément** du tableau **situé** à cet **indice.**
    
- `.**push()`Ajouter** un nouveau élément à la **fin d'un tableau** en utilisant la méthode .
    
    ```jsx
    tableau.push(element1, element2, ..., elementN);
    ```
    
- **`.unshift()`Ajouter au début** du ****tableau
- **`.indexOf()` : Rechercher la première occurrence d'un élément dans un tableau**
    
    ```jsx
    const fruits = ['pomme', 'banane', 'orange', 'fraise'];
    console.log(fruits.indexOf('orange')); // Affiche 2
    console.log(fruits.indexOf('mangue')); // Affiche -1 (car 'mangue' n'est pas dans le tableau)
    console.log(fruits.indexOf('fraise', 2)); // Affiche 3 (recherche à partir de l'index 2)
    ```
    
- **`.lastIndexOf()` : Rechercher la première occurrence d'un élément dans un tableau en commencent par le fin de l’arrays.**
- **`.pop()` Supprimer** le **dernier élément** d'un tableau en utilisant la méthode
- **`.shift()` Supprimer le premier élément** du tableau et return la valeur à stocker dans une variable
- **`.splice()`Supprimer un élément par son index**
- **`.splice(pos, n)`Supprimer des éléments à partir d'un index:**
    - à partir de la position **`pos`**(index).
    - **`n`** définit le nombre d'éléments à supprimer.
- **`.slice(start, end)` Copier un tableau :** à stocker dans une variable.
- **`.concat()`Fusionner 2 ou plusieurs tableaux -** `let nouveauTableau = tableau1.concat(tableau2);`
- **`.join(separator)`Renvoie** une **nouvelle** chaîne de caractères **en concaténant**
    - **`separator`** (optionnel) : Le séparateur à utiliser entre chaque élément de la chaîne résultante. Par défaut, c'est une virgule **`,`**.
    
    ```jsx
    let colors = ["Red", "Green", "Blue"];
    let result = colors.join(" - ");
    console.log(result); // Output: "Red - Green - Blue"
    ```
    
- **`.includes()`Vérifie** si un tableau **contient une certaine valeur  :** `true` si la valeur est présente, sinon `false`.
- `.**sort()`Trie les éléments** d'un tableau selon l'**ordre lexicographique** des chaînes de caractères
- `.**reverse()`Inverse l'ordre des éléments** d'un tableau.

[JavaScript | Arrays | Codecademy](https://www.codecademy.com/resources/docs/javascript/arrays)

### **Parcours d'un tableau**

Vous pouvez parcourir un tableau en utilisant une boucle `for`, une boucle `for...of`

```jsx
let tableau = [1, 2, 3];

// Boucle for
for (let i = 0; i < tableau.length; i++) {
    console.log(tableau[i]);
}

// Boucle for...of
for (let element of tableau) {
    console.log(element);
}

// forEach
tableau.forEach(function(element) {
    console.log(element);
});
```

- [**`.forEach()`**](https://www.codecademy.com/resources/docs/javascript/arrays/forEach?page_ref=catalog) **exécutera** le même code pour **chaque élément** (ici du tableau).

![https://content.codecademy.com/courses/learn-javascript-iterators/iterator anatomy.svg](https://content.codecademy.com/courses/learn-javascript-iterators/iterator anatomy.svg)

- **`groceries.forEach()`** appelle la méthode `forEach` sur le tableau `groceries`.
- **`.forEach()`** prend un argument de fonction de rappel. N'oubliez pas, une fonction de rappel est une fonction passée en argument dans une autre fonction.
- **`.forEach()`** parcourt le tableau et exécute la fonction de rappel pour chaque élément. Lors de chaque exécution, l'élément courant est passé en argument à la fonction de rappel.
- La valeur de retour pour `.forEach()` sera toujours `undefined`.

```jsx
const array1 = ['a', 'b', 'c'];
array1.forEach((element) => console.log(element));
// Expected output: "a"
// Expected output: "b"
// Expected output: "c"
```

# String

On peut **accéder** à chaque élément d’une chaine de caractéres **par son index comme** pour une **arrays.**

## **String Concatenation**

La concaténation de chaînes en JavaScript est le processus de fusion de deux chaînes de caractères en une seule.

```jsx
let prenom = "John";
let nom = "Doe";
let nomComplet = prenom + " " + nom;
console.log(nomComplet); // Affiche "John Doe"
```

nous pouvons **insérer**, ou interpoler, des **variables dans des chaînes de caractères** à l'aide de littéraux de gabarit. Dans l'exemple suivant, un littéral de modèle est utilisé pour relier des chaînes de caractères entre elles :

```jsx
const myPet = 'armadillo';
console.log(`I own a pet ${myPet}.`);
// Output: I own a pet armadillo.
```

- le littéral d'un template est entouré par des **backticks** ``` (**ALT GR de la touche 7**).
- À l'intérieur du littéral de template, vous verrez un espace réservé, **`${mypet}`**.
- Lorsque nous interpolons ``Je possède un animal ${mypet}.``,
    
    *Output : 'Je possède un tatou'.*
    

# **RegExp**

[JavaScript RegExp Reference](https://www.w3schools.com/jsref/jsref_obj_regexp.asp)

# ASCII

Comme dans de nombreux langages de programmation, les caractères sont **représentés en utilisant** le jeu de caractères **ASCII** (American Standard Code for Information Interchange) ou son extension Unicode

1. **Accès aux codes ASCII** :
    - Vous pouvez utiliser la méthode **`charCodeAt()`** sur une chaîne de caractères en JavaScript pour obtenir le code ASCII d'un caractère spécifique.
    
    - Par exemple :
        
        ```jsx
        let code = "A".charCodeAt(0); // Retourne le code ASCII de "A" (65)
        /*Syntax*/string.charCodeAt(index);
        ```
        
2. **Conversion de codes ASCII en caractères** :
    - Vous pouvez utiliser la méthode **`String.fromCharCode()`** pour convertir un code ASCII en caractère.
    - Par exemple :
        
        ```jsx
        let char = String.fromCharCode(65); // Retourne le caractère correspondant au code ASCII 65 ("A")
        ```
        
3. **Caractères de contrôle** :
    - Les codes ASCII de 0 à 31 sont des caractères de contrôle, qui ne sont généralement pas affichés. Ils sont utilisés pour des opérations de contrôle telles que le retour à la ligne, le saut de ligne, la tabulation, etc.
4. **Extension ASCII étendue** :
    - En plus des 128 premiers caractères ASCII, il existe une extension appelée ASCII étendu (ou ISO 8859-1) qui utilise les 8 bits complets pour représenter 256 caractères différents. Cela inclut des caractères accentués, des symboles spéciaux et d'autres caractères non présents dans le jeu de caractères ASCII standard.

## Built-in

- **`.split()`** (method) **permet de diviser un string en un tableau de sous-chaînes**, en utilisant un séparateur spécifié pour déterminer où effectuer la division.
    
    ```jsx
    const str = "apple,banana,orange,grape,kiwi";
    const fruits = str.split(',', 3); // Divise la chaîne à chaque virgule avec une limite de 3
    console.log(fruits); // Output: ["apple", "banana", "orange"]
    const str3 = "Hello";
    const letters = str3.split(''); // Divise la chaîne en caractères individuels
    console.log(letters); // Output: ["H", "e", "l", "l", "o"]
    ```
    

# Boucle

## for

- La boucle **`for`** est utilisée lorsque le nombre d'itérations est connu à l'avance.
- Elle se compose de trois parties : l'**initialisation, la condition et l'incrémentation**.

```jsx
for (Initialisation; Condition; Incrémentation/Décrémentation) {
}
// for (let i = 0; i < 5; i++) {}
```

### for…of

La boucle **`for...of`** est utilisée pour parcourir les éléments d'une structure de données itérable, tels que les tableaux, les chaînes de caractères, les ensembles, ou les objets itérables. 

```jsx
for (const element of iterable) {
// Code à exécuter pour chaque élément
}
const colors = ["red", "green", "blue"];
for (const color of colors) {
    console.log(color);
```

- **`element`** : Une variable qui va contenir chaque élément de l'itérable à chaque itération.
- **`iterable`** : La structure de données itérable à parcourir.

### for…in

La boucle **`for...in`** est utilisée pour parcourir les propriétés énumérables d'un objet. Voici la syntaxe de base :

```jsx
javascriptCopy code
for (const key in object) {
    // Code à exécuter pour chaque propriété
}
const person = {
    name: "John",
    age: 30,
    city: "New York"
};
for (const key in person) {
    console.log(key + ": " + person[key]);
}
```

- **`key`** : Une variable qui contiendra le nom de la propriété à chaque itération.
- **`object`** : L'objet dont les propriétés seront parcourues.

## **while**

- La boucle **`while`** est utilisée lorsque la condition de boucle peut être vérifiée avant l'exécution du bloc de code à l'intérieur.
- Elle continue à s'exécuter tant que la condition est vraie.

Exemple :

```jsx
javascriptCopy code
let i = 0;
while (i < 5) {
    // Bloc de code à répéter
    i++;
}

```

### **do...while**

La boucle **`do...while`** est similaire à la boucle **`while`**, mais elle garantit qu'au moins une itération du bloc de code est exécutée, même si la condition est fausse dès le départ.

Exemple :

```jsx
javascriptCopy code
let i = 0;
do {
    // Bloc de code à répéter
    i++;
} while (i < 5);

```

## **Utilisation de `Break`**

L'instruction **`break`**  permet de **sortir** d'une boucle prématurément ou d’une structure de contrôle **`switch`**. Elle est souvent utilisée lorsqu'une condition est rencontrée, et que l'on souhaite **arrêter** la boucle avant qu'elle ne se termine normalement.

```jsx
for (let i = 0; i < 5; i++) {
    if (i === 3) {
        break; // Sort de la boucle lorsque i est égal à 3
    }
    console.log(i);
}
// Affiche :
// 0
// 1
// 2
```

## **Utilisation de `continue`**

L'instruction  **`continue`**  permet de passer à la prochaine itération de la boucle, sans exécuter le reste du code présent dans la boucle pour l'itération en cours. Elle est souvent utilisée lorsqu'une condition est rencontrée, mais que l'on souhaite continuer la boucle sans exécuter le reste du code

```jsx
for (let i = 0; i < 5; i++) {
if (i === 2) {
continue; // Passe à l'itération suivante lorsque i est égal à 2
}
console.log(i);
}
// Affiche :
// 0
// 1
// 3
// 4
```

# Object

C’est un type de données intégré qui représente une collection de propriétés **clés-valeurs**. Les objets sont des éléments fondamentaux du langage et sont utilisés pour stocker et organiser des données de manière structurée.

1. **Création d'objets** :
    
    ![Untitled](JavaScript%20js%201ab66c37a9e74d499f189c8e82ba4e86/Untitled%201.png)
    
    - Vous pouvez créer un objet en utilisant la syntaxe littérale d'objet `{}`, en **utilisant** le **constructeur** **`new Object()`** ou en utilisant des fonctions constructeurs personnalisées.
    
    ```jsx
    const personne = {
        nom: 'John',
        age: 30,
        adresse: {
            rue: '123 rue Principale',
            ville: 'Ville Principale',
            pays: 'Pays Principale'
    	      'favorite foods': ['cookies', 'cakes', 'candy', 'spinach'],
    	      passengers: [{name: 'Space Dog'}] //tableau d'objets 
        }
    };
    ```
    
2. **Propriétés** :
    - Les objets sont composés de **paires KEY-VALUE**, où chaque **key = chaîne** ou **symbole** et chaque **valeur = n'importe quel type de données (**y compris autre objet).
    - Vous pouvez **accéder aux propriétés** d'un objet en utilisant :
        - **Notation pointée : `objet.propriete`**
        - **Notation entre crochets** : **`objet['propriete']`(Il doit s'agir d'une String)**.
        
        ```jsx
        console.log(personne.nom); // Affiche 'John'
        console.log(personne['age']); // Affiche 30
        console.log(personne.adresse['favorite foods'][0]);// Affiche cookies
        //use a variable inside the brackets
        personne["sexe"] = "Male"; // ajoute une propriete à l'objet personne
        personne.sexe = "Male"; // ajoute une propriete à l'objet personne
        let returnAnyProp = (objectName, propName) => objectName[propName];
        returnAnyProp(spaceship, 'homePlanet'); // Returns 'Earth'
        ```
        
    - **destructuration d'objets**:
        
        Permet d'extraire des valeurs d'un objet et de les assigner à des variables individuelles de manière concise. Cela rend la manipulation des données des objets plus concise et plus lisible.
        
        - **`const {prop1:pr1, prop2, city = "Unknown"} = obj;`**
            - **`prop1`**, **`prop2`** : Les noms des propriétés que vous souhaitez extraire de l'objet **`obj`**.
            - **`city = "Unknown"` :** Si la propriété **`city`** n'existe pas dans l'objet **`obj`**, la valeur par défaut "Unknown" est utilisée.
            - **`prop1:pr1` :** permet de **stocker la propriété** dans une **variable.**
            - **`obj`** : L'objet source à partir duquel vous souhaitez extraire les valeurs.
            
            ```jsx
            const person = {
                name: "John",
                age: 30,
                city: "New York"
            };
            		const {name:pers_name, age} = person;
            console.log(pers_name); // Output: "John"
            console.log(age); // Output: 30
            ```
            
3. **Tableau d’objet (arrays of objects)**
    
    ```jsx
    const movies = [
      {
        title: "Braveheart",
        year: 1995,
        director: "Mel Gipson",
      },
      {
        title: "Goodfellas",
        year: 1990,
        director: "Martin Scorsese",
      },
      {
        title: "The Godfather",
        year: 1972,
        director: "Francis Ford Coppola",
      }
    ];
    ```
    
    - On peut y **accéder** avec **`movies[2].title;` ou `movies[2].["title"];`**
    - **`JSON.stringify(value[, replacer[, space]])` : utilisée en JavaScript pour convertir des valeurs JavaScript en chaînes JSON (JavaScript Object Notation).**
        - **`value`** : La valeur JavaScript à convertir en chaîne JSON.
        - **`replacer`** (optionnel) : Une fonction de transformation ou un tableau spécifiant les propriétés à inclure ou exclure de la chaîne JSON résultante.
        - **`space`** (optionnel) : Un espace blanc optionnel ou un nombre d'espaces à utiliser pour l'indentation de la chaîne JSON résultante.
4. **Méthodes** :
    - Les méthodes sont des fonctions stockées en tant que valeurs de propriété d'un objet.
    - Vous pouvez appeler une méthode d'un objet en utilisant la notation pointée.
        
        ```jsx
        const objet = {
            methode:fontion() {
                console.log('Méthode appelée');
            }
            methode () {
                console.log('Méthode appelée');
            }
        };
        
        objet.methode(); // Affiche 'Méthode appelée'
        
        ```
        
    
    ## this
    
    1. **Dans une méthode d'objet :**
        
        Lorsque **`this`** est utilisé à l'intérieur d'une méthode d'objet, il **fait référence à l'objet lui-même sur lequel la méthode est appelée.**
        
        Exemple :
        
        ```jsx
        javascriptCopy code
        let objet = {
          propriete: 'valeur',
          methode: function() {
            console.log(this.propriete); // Fait référence à la propriété 'propriete' de l'objet
          }
        };
        objet.methode(); // Output: 'valeur'
        ```
        
    2. **Dans un constructeur d'objet :**
        
        Lorsqu'un constructeur est utilisé pour créer de nouveaux objets avec l'opérateur **`new`**, **`this`** fait référence à l'objet nouvellement créé. Par exemple :
        
        ```jsx
        function Objet(p) {
          this.propriete = p;
        }
        
        let nouvelObjet = new Objet('nouvelle valeur');
        console.log(nouvelObjet.propriete); // Output: 'nouvelle valeur'
        ```
        
    3. **Dans une fonction normale :**
        
        Lorsque **`this`** est utilisé dans une fonction normale (non méthode), son comportement dépend de la façon dont la fonction est appelée. En général, il fait référence à l'objet global (**`window`** dans un navigateur) ou à **`undefined`** en mode strict.
        
    4. **Dans les fonctions fléchées :**
        
        Les fonctions fléchées ne possèdent pas leur propre **`this`**. Elles capturent le **`this`** du contexte parent au moment de leur définition. Cela signifie qu'elles conservent le **`this`** de la portée où elles ont été définies, plutôt que d'avoir leur propre **`this`**.
        
        ```jsx
        const goat = {
          dietType: 'herbivore',
          makeSound() {
            console.log('baaa');
          },
          diet: () => {
            console.log(this.dietType);
          }
        };
        goat.diet(); // Prints undefined
        ```
        
        Les **fonctions fléchées** dans JavaScript **gèrent** le mot-clé `this` **différemment** des fonctions **classiques**. En gros, `this` dans une fonction fléchée ne change pas en fonction de comment on appelle la fonction, il garde la valeur qu'il avait à la création de la fonction.
        
        Dans votre exemple, la fonction fléchée est **créée en dehors de n'importe quel objet**. Donc, 
        
         par défaut fait référence à l'objet global qui n'a pas de propriété `dietType`. C'est pourquoi vous obtenez `undefined`.
        
5. **Modifications d'objets** :
    - Vous pouvez ajouter, **modifier ou supprimer** des propriétés d'un objet après sa création.
        
        ```jsx
        personne.age = 35; // Modifier la propriété age
        personne['profession'] = 'Développeur'; // Ajouter une nouvelle propriété
        delete personne.adresse; // Supprimer la propriété adresse
        // destructured assignment 
        const age = personne.age; //extraire des paires clé-valeur d'objets et les enregistrer en tant que variables.
        const { age } = personne; // shorthand de la ligne du dessus
        const { day } = vampire.preferences; // extraire des nested properties d'un objet et les enregistrer en tant que variables.
        ```
        
        - **`delete` :** Supprimer la propriété adresse.
6. **Itération sur les propriétés** :
    - Vous pouvez parcourir les propriétés d'un objet en utilisant une boucle **`for...in`**.
        
        ```jsx
        for (let cle in personne) {
            console.log(`${cle}: ${personne[cle]}`);
        }
        ```
        
    
    ## Set()
    
    Le type Set est une collection d'éléments uniques, ce qui signifie qu'il ne peut pas contenir de doublons.
    
    ### **Création d'un ensemble et ajout d'éléments :**
    
    ```jsx
    // Création d'un ensemble
    let ensemble = new Set();
    
    // Ajout d'éléments à l'ensemble
    ensemble.add(1);
    ensemble.add(2);
    ensemble.add(3);
    ensemble.add(4); // Les doublons ne seront pas ajoutés, donc cet élément ne sera pas ajouté
    console.log(ensemble); // Output: Set { 1, 2, 3 }
    ```
    
    ### **Vérification de l'existence d'un élément dans l'ensemble :**
    
    ```jsx
    console.log(ensemble.has(2)); // Output: true
    console.log(ensemble.has(4)); // Output: false
    ```
    
    ### **Suppression d'un élément de l'ensemble :**
    
    ```jsx
    ensemble.delete(2);
    console.log(ensemble); // Output: Set { 1, 3 }
    ```
    
    ### **Conversion d'un tableau en ensemble et vice versa :**
    
    ```jsx
    let tableau = [1, 2, 3, 1, 2, 4];
    let ensembleDuTableau = new Set(tableau); // Supprime automatiquement les doublons
    
    console.log(ensembleDuTableau); // Output: Set { 1, 2, 3, 4 }
    
    let tableauDeLEnsemble = Array.from(ensembleDuTableau);
    console.log(tableauDeLEnsemble); // Output: [ 1, 2, 3, 4 ]
    ```
    
    ### **Propriété size pour obtenir la taille de l'ensemble :**
    
    ```jsx
    console.log(ensemble.size); // Output: 2 (car nous avons supprimé un élément plus tôt)
    ```
    

### **Built-in Object Methods**

- **`Object.hasOwnProperty()` :**
    - Utilisée pour vérifier si un objet possède une propriété spécifiée en tant que propriété directe de cet objet (c'est-à-dire une propriété non héritée). Elle renvoie un booléen indiquant si l'objet possède ou non la propriété proprement dite.
    - **Syntaxe :`object.hasOwnProperty(propertyName)`**
    - **Retour :**
        - **`true`** si l'objet possède la propriété spécifiée en tant que propriété directe.
        - **`false`** sinon, y compris si la propriété est héritée de la chaîne de prototypes de l'objet.
        
        ```jsx
        const person = {
        name: "John",
        age: 30
        };
        console.log(person.hasOwnProperty("name")); // Output: true
        console.log(person.hasOwnProperty("toString")); /* Output: false 
        (toString est hérité)*/
        ```
        
- **`Object.assign()`** :
    - La méthode **`Object.assign()`** est utilisée pour **copier les valeurs de toutes** les **propriétés** énumérables propres d'**un** ou **plusieurs objets sources** **vers** un objet **cible**. Elle renvoie l'objet cible.
    - **Syntaxe : `Object.assign(cible, ...sources)`**
        
        ```jsx
        const obj1 = { a: 1, b: 2 };
        const obj2 = { b: 4, c: 5 };
        const obj3 = { d: 6 };
        
        const resultat = Object.assign({}, obj1, obj2, obj3);
        console.log(resultat); // { a: 1, b: 4, c: 5, d: 6 }
        
        ```
        
    - **`Object.keys()`** :
        - La méthode **`Object.keys()`** **renvoie un tableau** contenant les noms de **toutes** les **propriétés** énumérables propres d'un objet.
        - **Syntaxe : `Object.keys(objet)`**
            
            ```jsx
            const personne = {
              nom: 'John',
              age: 30,
              adresse: '123 rue Principale'
            };
            
            const proprietes = Object.keys(personne);
            console.log(proprietes); // ['nom', 'age', 'adresse']
            
            ```
            
    - **`Object.entries()`** :
        - La méthode `Object.entries()` renvoie un tableau contenant des paires de clé-valeur correspondant aux propriétés énumérables propres d'un objet, sous forme de tableaux.
        - **Syntaxe** : **`Object.entries(objet)`**
        
        ```jsx
        const personne = {
          nom: 'John',
          age: 30,
          adresse: '123 rue Principale'
        };
        
        const entries = Object.entries(personne);
        console.log(entries);
        // [['nom', 'John'], ['age', 30], ['adresse', '123 rue Principale']]
        ```
        
    
    ### **Privacy**
    
    Les développeurs JavaScript suivent des conventions de dénomination qui indiquent aux autres développeurs comment interagir avec une propriété. Une convention courante consiste à placer un trait de soulignement _ devant le nom d'une propriété pour signifier que la propriété ne doit pas être modifiée
    
    ```jsx
    const bankAccount = {
      _amount: 1000
    }
    ```
    
    ### **Getters**
    
    Ils sont des méthodes qui obtiennent et renvoient les propriétés internes d'un objet.
    
    - Les Getters peuvent effectuer une action sur les données lors de l'obtention d'une propriété.
    - Les Getters peuvent renvoyer différentes valeurs à l'aide de conditionnels.
    - Dans un getter, nous pouvons accéder aux propriétés de l'objet appelant en utilisant this.
    - La fonctionnalité de notre code est plus facile à comprendre pour les autres développeurs.
    
    ```jsx
    const objet = {
      _propriete: 'valeur',
      get propriete() {
        return this._propriete.toUpperCase();
      }
    };
    
    console.log(objet.propriete); // Affiche 'VALEUR'
    
    ```
    
    Dans cet exemple, `propriete` est un getter qui renvoie la valeur de la propriété `_propriete` convertie en majuscules.
    
    ### **Setters** :
    
    Les setters sont des méthodes spéciales utilisées pour **définir la valeur d'une propriété d'un objet**. Ils permettent un **accès contrôlé** aux **propriétés de l'objet** en fournissant une interface pour définir des valeurs, et ils sont souvent utilisés pour effectuer des opérations ou des validations lors de la définition d'une propriété.
    
    ```jsx
    const objet = {
      _propriete: '',
      set propriete(nouvelleValeur) {
        if (typeof nouvelleValeur === 'string') {
          this._propriete = nouvelleValeur.toLowerCase();
        } else {
          console.error('La valeur doit être une chaîne de caractères.');
        }
      }
    };
    
    objet.propriete = 'VALEUR';
    console.log(objet._propriete); // Affiche 'valeur'
    
    ```
    
    Dans cet exemple, `propriete` est un setter qui définit la valeur de la propriété `_propriete` en convertissant la valeur en minuscules.
    
    ### Factory Functions
    
    Les fonctions de fabrique sont des fonctions qui **retournent de nouveaux objets**. Elles sont **utiles** pour **créer plusieurs instances** d'objets avec des **propriétés** et des **comportements similaires.**
    
    ```jsx
    function creerObjet(nom, age) {
      return {
        nom: nom,
        age: age,
        direBonjour() {
          console.log(`Bonjour, je m'appelle ${this.nom} et j'ai ${this.age} ans.`);
        }
      };
    }
    //or shorthand
    function creerObjet(nom, age) {
      return {
        nom,
        age,
        direBonjour() {
          console.log(`Bonjour, je m'appelle ${this.nom} et j'ai ${this.age} ans.`);
        }
      };
    }
    const personne1 = creerObjet('Alice', 30);
    const personne2 = creerObjet('Bob', 25);
    
    personne1.direBonjour(); // Affiche "Bonjour, je m'appelle Alice et j'ai 30 ans."
    personne2.direBonjour(); // Affiche "Bonjour, je m'appelle Bob et j'ai 25 ans."
    ```
    
    Dans cet exemple, `creerObjet` est une fonction de fabrique qui crée un nouvel objet avec les propriétés `nom` et `age`, ainsi qu'une méthode `direBonjour`.
    
    En combinant ces concepts, vous pouvez créer des objets JavaScript avec des fonctionnalités et des comportements sophistiqués et bien structurés.
    

# **Try/Catch**

Le bloc **`try...catch`** est une structure de contrôle en JavaScript qui **permet** de **gérer les erreurs et les exceptions** de manière efficace.

1. **Bloc `try`** : Tout le code à surveiller est placé dans ce bloc. Si une exception est levée (une erreur survient) pendant l'exécution du code dans ce bloc, l'exécution de ce bloc est interrompue et le contrôle est transféré au bloc **`catch`**. Si aucune exception n'est levée, le bloc **`catch`** est ignoré.
2. **Bloc `catch`** : Ce bloc contient le code qui doit être exécuté si une exception est levée dans le bloc **`try`**. Il reçoit en général un paramètre, conventionnellement appelé **`error`** ou **`e`**, qui contient des informations sur l'exception qui a été levée.

```jsx
try {
  // Code susceptible de générer une erreur
  const result = 10 / 0; // Cette opération génère une erreur (division par zéro)
  console.log(result); // Cette ligne ne sera pas exécutée si une erreur survient
} catch (error) {
  // Gestion de l'erreur
  console.log("Une erreur s'est produite :", error);
}
```

L'utilisation de **`try...catch`** permet de gérer les erreurs de manière contrôlée, en **évitant** que les **erreurs non gérées ne provoquent l'arrêt brutal de l'exécution du script.** Cela permet également de fournir des **informations utiles sur les erreurs** qui se produisent, ce qui peut être très utile lors du débogage d'une application.

# Built-In Fonction

• [**Objects](https://www.codecademy.com/resources/docs/javascript/objects),** including instances of data types, can have properties, stored information. The properties are denoted with a . after the name of the object, for example: 'Hello'.length.

- **`includes()` :** utilisée pour déterminer si une chaîne de caractères contient une autre chaîne de caractères
    
    ```jsx
    string.includes(searchString, position)
    ```
    
    - **`string`** : **String** dans laquelle rechercher.
    - **`searchString`** : La **sous-chaîne** à **rechercher** dans **`string`**.
    - **`position`** (optionnel) : L'index de départ de la recherche dans **`string`**.
    
    ```jsx
    const str = "Hello, world!";
    console.log(str.includes("world")); // Output: true
    console.log(str.includes("World")); // Output: false (la casse est différente)
    console.log(str.includes("world", 7)); // Output: false (la sous-chaîne n'est pas trouvée à partir de l'index 7)
    ```
    
- **`setTimeout()`** :
Cette méthode est utilisée pour exécuter une fonction une seule fois après un délai spécifié, exprimé en millisecondes.
    
    **Syntaxe** : **`setTimeout(function, delay);`**
    
    ```jsx
    setTimeout(() => {
        console.log("Ce message s'affichera après 2 secondes");
    }, 2000);
    ```
    
- **`setInterval()`** :
**setInterval()** est utilisé pour **exécuter** une **fonction de manière répétée**, avec un **délai fixe** **entre chaque exécution**.
    
    **Syntaxe** : **`setInterval(function, delay);`**
    
    ```jsx
    let counter = 0;
    const intervalId = setInterval(() => {
        counter++;
        console.log("Ce message s'affichera toutes les secondes");
        if (counter === 5) {
            clearInterval(intervalId); // Arrête l'exécution répétée après 5 secondes
        }
    }, 1000);
    ```
    

## Methodes Built-in pour string

1. **eval()** : prend une chaîne de caractères et l'évalue comme du code JavaScript et donc permet d’exécuter dynamiquement du code JavaScript contenu dans une chaîne.
    
    ```jsx
    let x = 10;
    let y = 20;
    let result = eval("x + y");
    console.log(result); // Output: 30
    ```
    
2. **charAt(index)** : Méthode qui renvoie le caractère à l'index spécifié dans la chaîne de caractères.
    
    ```jsx
    const str = "Hello";
    console.log(str.charAt(0)); // Output: "H"
    ```
    
3. **concat(string2, string3, ...)** : Méthode qui concatène une ou plusieurs chaînes de caractères avec la chaîne courante et renvoie la nouvelle chaîne.
    
    ```jsx
    const str1 = "Hello";
    const str2 = " world";
    console.log(str1.concat(str2)); // Output: "Hello world"
    ```
    
4. **indexOf(substring[, fromIndex])** : Méthode qui renvoie l'index de la première occurrence de la sous-chaîne spécifiée dans la chaîne de caractères, ou -1 si la sous-chaîne n'est pas trouvée.
    
    ```jsx
    const str = "Hello world";
    console.log(str.indexOf("d")); // Output: 10
    ```
    
5. **lastIndexOf(substring[, fromIndex])** : Méthode qui renvoie l'index de la dernière occurrence de la sous-chaîne spécifiée dans la chaîne de caractères, ou -1 si la sous-chaîne n'est pas trouvée.
    
    ```jsx
    const str = "Hello world";
    console.log(str.lastIndexOf("o")); // Output: 7
    ```
    
6. **startsWith(searchString[, position])** : Méthode qui vérifie si la chaîne de caractères commence par la sous-chaîne spécifiée.
    
    ```jsx
    const str = "Hello world";
    console.log(str.startsWith("Hello")); // Output: true
    ```
    
7. **endsWith(searchString[, length])** : Méthode qui vérifie si la chaîne de caractères se termine par la sous-chaîne spécifiée.
    
    ```jsx
    const str = "Hello world";
    console.log(str.endsWith("world")); // Output: true
    ```
    
8. **substring(startIndex[, endIndex])** : Méthode qui extrait une sous-chaîne de la chaîne de caractères, en spécifiant les indices de début et de fin.
    
    ```jsx
    const str = "Hello world";
    console.log(str.substring(6, 11)); // Output: "world"
    
    ```
    
9. **substr(startIndex[, length])**) : Méthode extraire une sous-chaîne de caractères à partir d'une chaîne principale. Elle prend deux arguments : l'indice de départ (début) et éventuellement la longueur de la sous-chaîne à extraire.

Voici une explication détaillée de son fonctionnement :

- **`startIndex`** : L'indice de départ à partir duquel la sous-chaîne doit être extraite. Si cet argument est négatif, il est traité comme **`string.length + startIndex`**.
- **`length`** (optionnel) : La longueur de la sous-chaîne à extraire. Si cet argument est omis, la sous-chaîne sera extraite jusqu'à la fin de la chaîne principale. Si cet argument est négatif, il est traité comme 0.
    
    ### **Exemples :**
    
    ```jsx
    let str = "Hello World";
    let subStr = str.substr(0, 5); // Démarre à l'indice 0 (H) et extrait 5 caractères
    console.log(subStr); // Output: "Hello"
    ```
    
1. **slice(startIndex[, endIndex])** : Méthode qui extrait une sous-chaîne de la chaîne de caractères, en spécifiant les indices de début et de fin (la syntaxe est similaire à `substring()`, mais `slice()` accepte les indices négatifs).
    
    ```jsx
    const str = "Hello world";
    console.log(str.slice(-5)); // Output: "world"
    ```
    
2. **toLowerCase()** : Méthode qui convertit la chaîne de caractères en minuscules.
    
    ```jsx
    const str = "Hello";
    console.log(str.toLowerCase()); // Output: "hello"
    ```
    
3. **toUpperCase()** : Méthode qui convertit la chaîne de caractères en majuscules.
    
    ```jsx
    const str = "Hello";
    console.log(str.toUpperCase()); // Output: "HELLO"
    
    ```
    
4. **trim()** : Méthode qui supprime les espaces blancs au début et à la fin de la chaîne de caractères.
    
    ```jsx
    const str = "   Hello world   ";
    console.log(str.trim()); // Output: "Hello world"
    ```
    
5. **replace(searchValue, replaceValue)** : Méthode qui remplace une sous-chaîne spécifiée par une autre sous-chaîne dans la chaîne de caractères.
    
    ```jsx
    const str = "Hello world";
    console.log(str.replace("world", "universe")); // Output: "Hello universe"
    ```
    
6. **split(separator[, limit])** : Méthode qui divise la chaîne de caractères en un tableau de sous-chaînes, en utilisant un séparateur spécifié.
    
    ```jsx
    const str = "apple,banana,orange";
    console.log(str.split(",")); // Output: ["apple", "banana", "orange"]
    ```
    
7. **includes(searchString[, position])** : Méthode qui vérifie si la chaîne de caractères contient une sous-chaîne spécifiée.
    
    ```jsx
    const str = "Hello world";
    console.log(str.includes("world")); // Output: true
    ```
    
8. **match(regexp)** : Méthode qui recherche une correspondance entre une expression régulière et la chaîne de caractères.
    
    ```jsx
    const str = "Hello world";
    console.log(str.match(/world/)); // Output: ["world"]
    ```
    
9. **repeat(count)** : Méthode qui renvoie une nouvelle chaîne de caractères, contenant la chaîne de caractères d'origine concaténée autant de fois que spécifié.
    
    ```jsx
    const str = "Hello";
    console.log(str.repeat(3)); // Output: "HelloHelloHello"
    ```
    

## Methodes Built-in pour arrays

- **`.at()`** prend un **entier en argument** et **renvoie l'élément** du tableau **situé** à cet **indice.**
- `.**push()`Ajouter** un nouveau élément à la **fin d'un tableau** en utilisant la méthode .
    
    ```jsx
    tableau.push(element1, element2, ..., elementN);
    ```
    
- **`.unshift()`Ajouter au début** du ****tableau
- **`.indexOf()` Rechercher la première occurrence d'un élément dans un tableau**
    
    ```jsx
    const fruits = ['pomme', 'banane', 'orange', 'fraise'];
    console.log(fruits.indexOf('orange')); // Affiche 2
    console.log(fruits.indexOf('mangue')); // Affiche -1 (car 'mangue' n'est pas dans le tableau)
    console.log(fruits.indexOf('fraise', 2)); // Affiche 3 (recherche à partir de l'index 2)
    ```
    
- **`.pop()` Supprimer** le **dernier élément** d'un tableau en utilisant la méthode
- **`.shift()` Supprimer le premier élément** du tableau et return la valeur à stocker dans une variable
- **`.splice()`Supprimer un élément par son index**
- **`.splice(pos, n)`Supprimer des éléments à partir d'un index:**
    - **`n`** définit le nombre d'éléments à supprimer.
    - à partir de la position **`pos`**.
- **`.slice(start, end)` Copier un tableau :** à stocker dans une variable.
- **`.concat()`Fusionner 2 ou plusieurs tableaux -** `let nouveauTableau = tableau1.concat(tableau2);`
- **`.join()`Renvoie** une **nouvelle** chaîne de caractères **en concaténant**
- **`.includes()`Vérifie** si un tableau **contient une certaine valeur  :** `true` si la valeur est présente, sinon `false`.
- `.**sort()`Trie les éléments** d'un tableau selon l'**ordre lexicographique** des chaînes de caractères et renvoie le tableau.
- `.**reverse()`Inverse l'ordre des éléments** d'un tableau.

## **Méthode** :

Une méthode est une fonction qui est associée à un objet spécifique. Les méthodes sont souvent appelées sur des objets et agissent sur ces objets. Elle fonctions qui sont stockées en tant que propriétés d'un objet.

1. Les méthodes sont appelées en utilisant la syntaxe "objet.méthode()".

---

- **`.length`** : utilisée pour obtenir la taille ou la longueur d'une chaîne de caractères, d'un tableau ou d'autres types de données appropriés.
- **`.toUpperCase()` : Convertit** une chaîne de caractères en **majuscules**.
- **`.startsWith()` :** **vérifie** si une chaîne **commence par les caractères spécifiés**. **Return** **`True`** si oui, sinon **Return** **`False`**
- **`.trim()` :** **supprime** les **espaces blancs** aux **deux extrémités** de cette chaîne et renvoie une nouvelle chaîne, sans modifier la chaîne d'origine
    - **`.trimStart()` : supprime** les **espaces blancs du début** de la chaine de caractères.
    - **`.trimEnd()` : supprime** les **espaces blancs de la Fin** de la chaine de caractères.

### Math Object

- **`Math.random()`** : renvoie un **nombre pseudo-aléatoire** en virgule **flottante** **supérieur ou égal à 0 et inférieur à 1**, avec une distribution approximativement uniforme sur cette plage - que vous pouvez ensuite adapter à la plage souhaitée. L'implémentation sélectionne la graine initiale de l'algorithme de génération de nombres aléatoires ; elle ne peut pas être choisie ou réinitialisée par l'utilisateur.
    - Pour **générer** un **nombre aléatoire entre 0 et 50**, nous pouvons multiplier ce résultat par 50, comme suit :
        
        ```jsx
        Math.random() * 50;
        ```
        
- **`Math.floor()` :** prend un nombre décimal et l'arrondit au nombre entier inférieur le plus proche.
- **`Math.ceil()` : arrondit toujours à l'unité supérieure** et renvoie le plus petit entier supérieur ou égal à un nombre donné.
- **`Math.min()` :**
    
    Renvoie le plus petit nombre parmi les arguments fournis.
    
    **Syntax : `Math.min(num1, num2, ..., numN)` ou avec une list `Math.min(...numbers);`**
    
    ```jsx
    let minValue = Math.min(5, 3, 8, 2);
    console.log(minValue); // Output: 2
    ```
    
    **Remarques** :
    
    - Si aucun argument n'est fourni, **`Math.min()`** renvoie **`Infinity`**.
    - Si l'un des arguments n'est pas un nombre valide, la fonction renvoie **`NaN`**.
- **`Math.max()`**
    
    Renvoie le plus grand nombre parmi les arguments fournis.
    

**Syntax : `Math.max(num1, num2, ..., numN)` ou avec une list `Math.max(...numbers);`**

```jsx
let maxValue = Math.max(5, 3, 8, 2);
console.log(maxValue); // Output: 2
```

**Remarques** :

- Si aucun argument n'est fourni, **`Math.max+()`** renvoie **`Infinity`**.
- Si l'un des arguments n'est pas un nombre valide, la fonction renvoie **`NaN`**.

### Number Object

- **`Number.isInteger()`** détermine si la valeur transmise est un entier.

[<Sommaire>](https://www.notion.so/Sommaire-25758c740bb34c809288a4714fe8c6d0?pvs=21)
